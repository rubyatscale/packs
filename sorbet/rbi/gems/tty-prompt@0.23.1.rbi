# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `tty-prompt` gem.
# Please instead update this file by running `bin/tapioca gem tty-prompt`.

module TTY; end

class TTY::Prompt
  extend ::Forwardable

  def initialize(input: T.unsafe(nil), output: T.unsafe(nil), env: T.unsafe(nil), symbols: T.unsafe(nil), prefix: T.unsafe(nil), interrupt: T.unsafe(nil), track_history: T.unsafe(nil), quiet: T.unsafe(nil), enable_color: T.unsafe(nil), active_color: T.unsafe(nil), help_color: T.unsafe(nil), error_color: T.unsafe(nil)); end

  def active_color; end
  def ask(message = T.unsafe(nil), **options, &block); end
  def clear_line(*args, &block); end
  def clear_lines(*args, &block); end
  def collect(**options, &block); end
  def count_screen_lines(*args, &block); end
  def cursor; end
  def debug(*messages); end
  def decorate(string, *colors); end
  def enabled_color; end
  def enum_select(question, *args, &block); end
  def error(*args, **options); end
  def error_color; end
  def expand(message, *args, &block); end
  def flush(*args, &block); end
  def help_color; end
  def hide(*args, &block); end
  def input; end
  def inspect; end
  def invoke_question(object, message, **options, &block); end
  def invoke_select(object, question, *args, &block); end
  def keypress(message = T.unsafe(nil), **options, &block); end
  def mask(message = T.unsafe(nil), **options, &block); end
  def multi_select(question, *args, &block); end
  def multiline(message = T.unsafe(nil), **options, &block); end
  def no?(message, **options, &block); end
  def ok(*args, **options); end
  def on(*args, &block); end
  def output; end
  def prefix; end
  def print(*args, &block); end
  def puts(*args, &block); end
  def quiet; end
  def read_char(*args, &block); end
  def read_keypress(*args, &block); end
  def read_line(*args, &block); end
  def read_multiline(*args, &block); end
  def reader; end
  def say(message = T.unsafe(nil), **options); end
  def select(question, *args, &block); end
  def show(*args, &block); end
  def slider(question, choices = T.unsafe(nil), **options, &block); end
  def stderr; end
  def stdin; end
  def stdout; end
  def strip(*args, &block); end
  def subscribe(*args, &block); end
  def suggest(message, possibilities, **options); end
  def symbols; end
  def trigger(*args, &block); end
  def tty?; end
  def unsubscribe(*args, &block); end
  def warn(*args, **options); end
  def yes?(message, **options, &block); end

  class << self
    def messages; end
  end
end

class TTY::Prompt::AnswersCollector
  def initialize(prompt, **options); end

  def add_answer(answer); end
  def call(&block); end
  def create_collector; end
  def key(name, &block); end
  def values(&block); end

  private

  def method_missing(method, *args, **options, &block); end
end

class TTY::Prompt::ArgumentRequired < ::TTY::Prompt::Error; end
class TTY::Prompt::ArgumentValidation < ::TTY::Prompt::Error; end

class TTY::Prompt::BlockPaginator < ::TTY::Prompt::Paginator
  def paginate(list, active, per_page = T.unsafe(nil), &block); end
end

class TTY::Prompt::Choice
  def initialize(name, value, **options); end

  def ==(other); end
  def disabled; end
  def disabled?; end
  def key; end
  def name; end
  def to_s; end
  def value; end

  class << self
    def convert_array(val); end
    def convert_hash(val); end
    def from(val); end
  end
end

class TTY::Prompt::Choices
  include ::Enumerable
  extend ::Forwardable

  def initialize(choices = T.unsafe(nil)); end

  def <<(choice); end
  def ==(*args, &block); end
  def [](index); end
  def each(&block); end
  def empty?(*args, &block); end
  def enabled; end
  def enabled_indexes; end
  def find_by(attr, value); end
  def index(*args, &block); end
  def length(*args, &block); end
  def pluck(name); end
  def size(*args, &block); end
  def to_ary(*args, &block); end
  def values_at(*args, &block); end

  protected

  def choices; end

  class << self
    def [](*choices); end
  end
end

class TTY::Prompt::ConfigurationError < ::TTY::Prompt::Error; end

class TTY::Prompt::ConfirmQuestion < ::TTY::Prompt::Question
  def initialize(prompt, **options); end

  def call(message, &block); end
  def negative(value = T.unsafe(nil)); end
  def negative?; end
  def positive(value = T.unsafe(nil)); end
  def positive?; end
  def render_question; end
  def suffix(value = T.unsafe(nil)); end
  def suffix?; end

  protected

  def conversion; end
  def create_default_labels; end
  def create_suffix; end
  def infer_default; end
  def process_input(question); end
  def setup_defaults; end
end

module TTY::Prompt::Const; end
TTY::Prompt::Const::Undefined = T.let(T.unsafe(nil), Object)
class TTY::Prompt::ConversionAlreadyDefined < ::TTY::Prompt::Error; end
class TTY::Prompt::ConversionError < ::TTY::Prompt::Error; end

module TTY::Prompt::ConverterDSL
  def convert(name, input); end
  def converter(*names, &block); end
  def converter_registry; end
end

class TTY::Prompt::ConverterRegistry
  extend ::Forwardable

  def initialize(registry = T.unsafe(nil)); end

  def [](name); end
  def contain?(name); end
  def fetch(name); end
  def inspect; end
  def keys(*args, &block); end
  def register(*names, &block); end
end

module TTY::Prompt::Converters
  extend ::TTY::Prompt::ConverterDSL

  private

  def cast_to_num(num); end

  class << self
    def cast_to_num(num); end
  end
end

TTY::Prompt::Converters::DIGIT_MATCHER = T.let(T.unsafe(nil), Regexp)
TTY::Prompt::Converters::FALSE_VALUES = T.let(T.unsafe(nil), Regexp)
TTY::Prompt::Converters::LETTER_MATCHER = T.let(T.unsafe(nil), Regexp)
TTY::Prompt::Converters::SINGLE_DIGIT_MATCHER = T.let(T.unsafe(nil), Regexp)
TTY::Prompt::Converters::TRUE_VALUES = T.let(T.unsafe(nil), Regexp)

class TTY::Prompt::Distance
  def distance(first, second); end
end

class TTY::Prompt::EnumList
  def initialize(prompt, **options); end

  def call(question, possibilities, &block); end
  def choice(*value, &block); end
  def choices(values = T.unsafe(nil)); end
  def default(default); end
  def default?; end
  def enum(value); end
  def keyenter(*_arg0); end
  def keyleft(*_arg0); end
  def keypress(event); end
  def keyreturn(*_arg0); end
  def keyright(*_arg0); end
  def keytab(*_arg0); end
  def page_help(text); end
  def page_size; end
  def paginated?; end
  def per_page(value); end
  def quiet(value); end
  def symbols(new_symbols = T.unsafe(nil)); end

  private

  def answer; end
  def error_message; end
  def mark_choice_as_active; end
  def page_help_message; end
  def question_lines_count(question_lines); end
  def refresh(lines); end
  def render; end
  def render_error; end
  def render_footer; end
  def render_header; end
  def render_menu; end
  def render_page_help; end
  def render_question; end
  def setup_defaults; end
  def validate_default_name; end
  def validate_defaults; end
end

TTY::Prompt::EnumList::INTEGER_MATCHER = T.let(T.unsafe(nil), Regexp)
TTY::Prompt::EnumList::PAGE_HELP = T.let(T.unsafe(nil), String)
class TTY::Prompt::Error < ::StandardError; end

class TTY::Prompt::Evaluator
  def initialize(question, &block); end

  def <<(proc = T.unsafe(nil), &block); end
  def call(initial); end
  def check(proc = T.unsafe(nil), &block); end
  def results; end
end

class TTY::Prompt::Expander
  def initialize(prompt, options = T.unsafe(nil)); end

  def call(message, possibilities, &block); end
  def choice(value, &block); end
  def choices(values); end
  def collapsed?; end
  def default(value = T.unsafe(nil)); end
  def expand; end
  def expanded?; end
  def keyenter(_); end
  def keypress(event); end
  def keyreturn(_); end
  def quiet(value); end
  def select_choice(key); end

  private

  def answer; end
  def load_auto_hint; end
  def possible_keys; end
  def read_input; end
  def refresh(lines); end
  def render; end
  def render_footer; end
  def render_header; end
  def render_hint; end
  def render_menu; end
  def render_question; end
  def setup_defaults; end
  def validate_choices; end
end

TTY::Prompt::Expander::DELETE_KEYS = T.let(T.unsafe(nil), Array)
TTY::Prompt::Expander::HELP_CHOICE = T.let(T.unsafe(nil), Hash)
class TTY::Prompt::InvalidArgument < ::TTY::Prompt::Error; end

class TTY::Prompt::Keypress < ::TTY::Prompt::Question
  def initialize(prompt, **options); end

  def any_key?; end
  def countdown(value = T.unsafe(nil)); end
  def interval_handler(time); end
  def keypress(event); end
  def process_input(question); end
  def refresh(lines, lines_to_clear); end
  def render_question; end
  def timeout?; end
end

class TTY::Prompt::List
  def initialize(prompt, **options); end

  def arrows_help; end
  def call(question, possibilities, &block); end
  def choice(*value, &block); end
  def choices(values = T.unsafe(nil)); end
  def default(*default_values); end
  def default_help; end
  def enum(value); end
  def enumerate?; end
  def help(value = T.unsafe(nil)); end
  def keybackspace(*_arg0); end
  def keydelete(*_arg0); end
  def keydown(*_arg0); end
  def keyenter(*_arg0); end
  def keyleft(*_arg0); end
  def keynum(event); end
  def keypage_down(*_arg0); end
  def keypage_up(*_arg0); end
  def keypress(event); end
  def keyreturn(*_arg0); end
  def keyright(*_arg0); end
  def keyspace(*_arg0); end
  def keytab(*_arg0); end
  def keyup(*_arg0); end
  def page_size; end
  def paginated?; end
  def paginator; end
  def per_page(value); end
  def quiet(value); end
  def search_choice_in(searchable); end
  def show_help(value = T.unsafe(nil)); end
  def symbols(new_symbols = T.unsafe(nil)); end
  def sync_paginators; end

  private

  def answer; end
  def check_options_consistency(options); end
  def filter_help; end
  def filterable?; end
  def help_always?; end
  def help_start?; end
  def question_lines_count(question_lines); end
  def refresh(lines); end
  def render; end
  def render_header; end
  def render_menu; end
  def render_question; end
  def setup_defaults; end
  def validate_default_name(name); end
  def validate_defaults; end
end

TTY::Prompt::List::FILTER_KEYS_MATCHER = T.let(T.unsafe(nil), Regexp)
TTY::Prompt::List::INTEGER_MATCHER = T.let(T.unsafe(nil), Regexp)

class TTY::Prompt::MaskQuestion < ::TTY::Prompt::Question
  def initialize(prompt, **options); end

  def keyenter(_event); end
  def keypress(event); end
  def keyreturn(_event); end
  def mask(char = T.unsafe(nil)); end
  def read_input(question); end
  def render_error(errors); end
  def render_question; end
end

TTY::Prompt::MaskQuestion::DELETE_KEYS = T.let(T.unsafe(nil), Array)

class TTY::Prompt::MultiList < ::TTY::Prompt::List
  def initialize(prompt, **options); end

  def keyctrl_a(*_arg0); end
  def keyctrl_r(*_arg0); end
  def keyenter(*_arg0); end
  def keyreturn(*_arg0); end
  def keyspace(*_arg0); end
  def max(value); end
  def min(value); end

  private

  def answer; end
  def default_help; end
  def minmax_help; end
  def render_header; end
  def render_menu; end
  def selected_names; end
  def setup_defaults; end
end

class TTY::Prompt::Multiline < ::TTY::Prompt::Question
  def initialize(prompt, **options); end

  def help(value = T.unsafe(nil)); end
  def keyenter(*_arg0); end
  def keyreturn(*_arg0); end
  def process_input(question); end
  def read_input; end
  def refresh(lines, lines_to_clear); end
  def render_question; end
end

TTY::Prompt::Multiline::HELP = T.let(T.unsafe(nil), String)

class TTY::Prompt::Paginator
  def initialize(**options); end

  def check_page_size!; end
  def current_index; end
  def end_index; end
  def last_index; end
  def paginate(list, active, per_page = T.unsafe(nil), &block); end
  def reset!; end
  def start_index; end
  def start_index=(_arg0); end
end

TTY::Prompt::Paginator::DEFAULT_PAGE_SIZE = T.let(T.unsafe(nil), Integer)

class TTY::Prompt::Question
  include ::TTY::Prompt::Question::Checks

  def initialize(prompt, **options); end

  def call(message = T.unsafe(nil), &block); end
  def convert(value = T.unsafe(nil), message = T.unsafe(nil)); end
  def convert?; end
  def convert_result(value); end
  def default(value = T.unsafe(nil)); end
  def default?; end
  def echo(value = T.unsafe(nil)); end
  def echo?(value = T.unsafe(nil)); end
  def in(value = T.unsafe(nil), message = T.unsafe(nil)); end
  def in?; end
  def inspect; end
  def message; end
  def message_for(name, tokens = T.unsafe(nil)); end
  def messages; end
  def modifier; end
  def modify(*rules); end
  def process_input(question); end
  def quiet(value); end
  def raw(value = T.unsafe(nil)); end
  def raw?(value = T.unsafe(nil)); end
  def read_input(question); end
  def refresh(lines, lines_to_clear); end
  def render; end
  def render_error(errors); end
  def render_question; end
  def required(value = T.unsafe(nil), message = T.unsafe(nil)); end
  def required?(value = T.unsafe(nil), message = T.unsafe(nil)); end
  def to_s; end
  def validate(value = T.unsafe(nil), message = T.unsafe(nil), &block); end
  def validation; end
  def validation?; end
  def value(val); end
  def value?; end
end

module TTY::Prompt::Question::Checks; end

class TTY::Prompt::Question::Checks::CheckConversion
  class << self
    def call(question, value); end
  end
end

class TTY::Prompt::Question::Checks::CheckDefault
  class << self
    def call(question, value); end
  end
end

class TTY::Prompt::Question::Checks::CheckModifier
  class << self
    def call(question, value); end
  end
end

class TTY::Prompt::Question::Checks::CheckRange
  class << self
    def call(question, value); end
    def cast(value); end
    def float?(value); end
    def int?(value); end
  end
end

class TTY::Prompt::Question::Checks::CheckRequired
  class << self
    def call(question, value); end
  end
end

class TTY::Prompt::Question::Checks::CheckValidation
  class << self
    def call(question, value); end
  end
end

class TTY::Prompt::Question::Modifier
  def initialize(modifiers); end

  def apply_to(value); end
  def modifiers; end

  class << self
    def letter_case(mod, value); end
    def whitespace(mod, value); end
  end
end

class TTY::Prompt::Question::UndefinedSetting
  def inspect; end
  def to_s; end
end

class TTY::Prompt::Question::Validation
  def initialize(pattern); end

  def call(input); end
  def coerce(pattern); end
  def pattern; end
end

TTY::Prompt::Question::Validation::VALIDATORS = T.let(T.unsafe(nil), Hash)

class TTY::Prompt::Result
  def initialize(question, value, errors = T.unsafe(nil)); end

  def errors; end
  def failure?; end
  def question; end
  def success?; end
  def value; end
  def with(condition = T.unsafe(nil), &block); end
end

class TTY::Prompt::Result::Failure < ::TTY::Prompt::Result; end
class TTY::Prompt::Result::Success < ::TTY::Prompt::Result; end

class TTY::Prompt::SelectedChoices
  include ::Enumerable

  def initialize(selected = T.unsafe(nil), indexes = T.unsafe(nil)); end

  def clear; end
  def delete_at(index); end
  def each(&block); end
  def find_index_by(&search); end
  def insert(index, choice); end
  def size; end
end

class TTY::Prompt::Slider
  def initialize(prompt, **options); end

  def call(question, possibilities = T.unsafe(nil), &block); end
  def choice(*value, &block); end
  def choices(values = T.unsafe(nil)); end
  def default(value); end
  def default_help; end
  def format(value); end
  def help(text = T.unsafe(nil)); end
  def initial; end
  def keydown(*_arg0); end
  def keyenter(*_arg0); end
  def keyleft(*_arg0); end
  def keyreturn(*_arg0); end
  def keyright(*_arg0); end
  def keyspace(*_arg0); end
  def keyup(*_arg0); end
  def max(value); end
  def min(value); end
  def quiet(value); end
  def show_help(value = T.unsafe(nil)); end
  def step(value); end
  def symbols(new_symbols = T.unsafe(nil)); end

  private

  def answer; end
  def help_always?; end
  def help_start?; end
  def refresh(lines); end
  def render; end
  def render_question; end
  def render_slider; end
end

TTY::Prompt::Slider::FORMAT = T.let(T.unsafe(nil), String)
TTY::Prompt::Slider::HELP = T.let(T.unsafe(nil), String)

class TTY::Prompt::Statement
  def initialize(prompt, newline: T.unsafe(nil), color: T.unsafe(nil)); end

  def call(message); end
  def color; end
  def newline; end
end

module TTY::Prompt::StringIOExtensions
  def ioctl(*_arg0); end
  def wait_readable(*_arg0); end
end

class TTY::Prompt::Suggestion
  def initialize(**options); end

  def indent; end
  def plural_text; end
  def single_text; end
  def suggest(message, possibilities); end

  private

  def build_multiple_suggestions; end
  def build_single_suggestion; end
  def evaluate; end
  def measure_distances(message, possibilities); end
end

TTY::Prompt::Suggestion::DEFAULT_INDENT = T.let(T.unsafe(nil), Integer)
TTY::Prompt::Suggestion::PLURAL_TEXT = T.let(T.unsafe(nil), String)
TTY::Prompt::Suggestion::SINGLE_TEXT = T.let(T.unsafe(nil), String)

module TTY::Prompt::Symbols
  private

  def symbols; end
  def windows?; end

  class << self
    def symbols; end
    def windows?; end
  end
end

TTY::Prompt::Symbols::KEYS = T.let(T.unsafe(nil), Hash)
TTY::Prompt::Symbols::WIN_KEYS = T.let(T.unsafe(nil), Hash)

class TTY::Prompt::Test < ::TTY::Prompt
  def initialize(**options); end
end

class TTY::Prompt::Timer
  def initialize(duration, interval); end

  def duration; end
  def interval; end
  def on_tick(&block); end
  def runtime; end
  def start; end
  def stop; end
  def time_now; end
  def total; end
  def while_remaining; end
end

class TTY::Prompt::UnsupportedConversion < ::TTY::Prompt::Error; end
TTY::Prompt::VERSION = T.let(T.unsafe(nil), String)
class TTY::Prompt::ValidationCoercion < ::TTY::Prompt::Error; end

module TTY::Utils
  private

  def blank?(value); end
  def deep_copy(object); end
  def extract_options(args); end
  def extract_options!(args); end

  class << self
    def blank?(value); end
    def deep_copy(object); end
    def extract_options(args); end
    def extract_options!(args); end
  end
end

TTY::Utils::BLANK_REGEX = T.let(T.unsafe(nil), Regexp)
