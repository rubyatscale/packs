# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `packwerk` gem.
# Please instead update this file by running `bin/tapioca gem packwerk`.

class Packwerk::Configuration
  def initialize(configs = T.unsafe(nil), config_path: T.unsafe(nil)); end

  def cache_directory; end
  def cache_enabled?; end
  def config_path; end
  def custom_associations; end
  def exclude; end
  def include; end
  def load_paths; end
  def package_paths; end
  def parallel?; end
  def root_path; end

  class << self
    def from_path(path = T.unsafe(nil)); end

    private

    def from_packwerk_config(path); end
  end
end

class Packwerk::Cli
  sig do
    params(
      configuration: T.nilable(::Packwerk::Configuration),
      out: T.any(::IO, ::StringIO),
      err_out: T.any(::IO, ::StringIO),
      environment: ::String,
      style: ::Packwerk::OutputStyle,
      offenses_formatter: T.nilable(::Packwerk::OffensesFormatter)
    ).void
  end
  def initialize(configuration: T.unsafe(nil), out: T.unsafe(nil), err_out: T.unsafe(nil), environment: T.unsafe(nil), style: T.unsafe(nil), offenses_formatter: T.unsafe(nil)); end

  sig { params(args: T::Array[::String]).returns(T::Boolean) }
  def execute_command(args); end

  sig { params(args: T::Array[::String]).returns(T.noreturn) }
  def run(args); end
end

class Packwerk::ReferenceOffense < ::Packwerk::Offense
  sig do
    params(
      reference: ::Packwerk::Reference,
      violation_type: ::Packwerk::ViolationType,
      location: T.nilable(::Packwerk::Node::Location)
    ).void
  end
  def initialize(reference:, violation_type:, location: T.unsafe(nil)); end

  sig { returns(::Packwerk::Reference) }
  def reference; end

  sig { returns(::Packwerk::ViolationType) }
  def violation_type; end

  private

  sig { params(reference: ::Packwerk::Reference, violation_type: ::Packwerk::ViolationType).returns(::String) }
  def build_message(reference, violation_type); end
end

class Packwerk::ViolationType < ::T::Enum
  enums do
    Privacy = new
    Dependency = new
  end
end

module Packwerk::OutputStyle
  interface!

  sig { abstract.returns(::String) }
  def error; end

  sig { abstract.returns(::String) }
  def filename; end

  sig { abstract.returns(::String) }
  def reset; end
end


class Packwerk::Node::Location < ::Struct
  def column; end
  def column=(_); end
  def line; end
  def line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Packwerk::Offense
  sig { params(file: ::String, message: ::String, location: T.nilable(::Packwerk::Node::Location)).void }
  def initialize(file:, message:, location: T.unsafe(nil)); end

  sig { returns(::String) }
  def file; end

  sig { returns(T.nilable(::Packwerk::Node::Location)) }
  def location; end

  sig { returns(::String) }
  def message; end

  sig { params(style: ::Packwerk::OutputStyle).returns(::String) }
  def to_s(style = T.unsafe(nil)); end
end


class Packwerk::Reference < ::Struct
  def constant; end
  def constant=(_); end
  def relative_path; end
  def relative_path=(_); end
  def source_location; end
  def source_location=(_); end
  def source_package; end
  def source_package=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Packwerk::DeprecatedReferences
  sig { params(package: ::Packwerk::Package, filepath: ::String).void }
  def initialize(package, filepath); end

  sig { params(reference: ::Packwerk::Reference, violation_type: ::Packwerk::ViolationType).returns(T::Boolean) }
  def add_entries(reference, violation_type); end

  sig { void }
  def dump; end

  sig { params(reference: ::Packwerk::Reference, violation_type: ::Packwerk::ViolationType).returns(T::Boolean) }
  def listed?(reference, violation_type:); end

  sig { returns(T::Boolean) }
  def stale_violations?; end

  private

  sig { returns(T::Hash[::String, T.untyped]) }
  def deprecated_references; end

  sig { params(filepath: ::String).returns(T::Hash[::String, T.untyped]) }
  def load_yaml(filepath); end

  sig { returns(T::Hash[::String, T.untyped]) }
  def prepare_entries_for_dump; end
end

class Packwerk::Package
  include ::Comparable

  sig { params(name: ::String, config: T.nilable(T.any(::FalseClass, T::Hash[T.untyped, T.untyped]))).void }
  def initialize(name:, config:); end

  sig { params(other: T.untyped).returns(T.nilable(::Integer)) }
  def <=>(other); end

  sig { returns(T::Array[::String]) }
  def dependencies; end

  sig { params(package: ::Packwerk::Package).returns(T::Boolean) }
  def dependency?(package); end

  sig { returns(T::Boolean) }
  def enforce_dependencies?; end

  sig { returns(T.nilable(T.any(T::Array[::String], T::Boolean))) }
  def enforce_privacy; end

  sig { params(other: T.untyped).returns(T::Boolean) }
  def eql?(other); end

  sig { returns(::Integer) }
  def hash; end

  sig { returns(::String) }
  def name; end

  sig { params(path: ::String).returns(T::Boolean) }
  def package_path?(path); end

  sig { returns(::String) }
  def public_path; end

  sig { params(path: ::String).returns(T::Boolean) }
  def public_path?(path); end

  sig { returns(T::Boolean) }
  def root?; end

  sig { returns(::String) }
  def to_s; end

  sig { returns(T.nilable(::String)) }
  def user_defined_public_path; end
end

class Packwerk::OffenseCollection
  sig do
    params(
      root_path: ::String,
      deprecated_references: T::Hash[::Packwerk::Package, ::Packwerk::DeprecatedReferences]
    ).void
  end
  def initialize(root_path, deprecated_references = T.unsafe(nil)); end

  sig { params(offense: ::Packwerk::Offense).void }
  def add_offense(offense); end

  sig { void }
  def dump_deprecated_references_files; end

  sig { returns(T::Array[::Packwerk::Offense]) }
  def errors; end

  sig { params(offense: ::Packwerk::Offense).returns(T::Boolean) }
  def listed?(offense); end

  sig { returns(T::Array[::Packwerk::ReferenceOffense]) }
  def new_violations; end

  sig { returns(T::Array[::Packwerk::Offense]) }
  def outstanding_offenses; end

  sig { returns(T::Boolean) }
  def stale_violations?; end

  private

  sig { params(package: ::Packwerk::Package).returns(::String) }
  def deprecated_references_file_for(package); end

  sig { params(package: ::Packwerk::Package).returns(::Packwerk::DeprecatedReferences) }
  def deprecated_references_for(package); end
end


module Packwerk::OffensesFormatter
  interface!

  sig { abstract.params(offenses: T::Array[T.nilable(::Packwerk::Offense)]).returns(::String) }
  def show_offenses(offenses); end

  sig { abstract.params(offense_collection: ::Packwerk::OffenseCollection).returns(::String) }
  def show_stale_violations(offense_collection); end
end

class Packwerk::OutputStyles::Coloured
  include ::Packwerk::OutputStyle

  sig { override.returns(::String) }
  def error; end

  sig { override.returns(::String) }
  def filename; end

  sig { override.returns(::String) }
  def reset; end
end
