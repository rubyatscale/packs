# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `visualize_packs` gem.
# Please instead update this file by running `bin/tapioca gem visualize_packs`.

# source://visualize_packs//lib/visualize_packs/node_interface.rb#3
module VisualizePacks
  class << self
    # source://visualize_packs//lib/visualize_packs.rb#21
    sig { params(packages: T::Array[::Packs::Pack]).void }
    def package_graph!(packages); end

    # source://visualize_packs//lib/visualize_packs.rb#26
    sig { params(teams: T::Array[::CodeTeams::Team]).void }
    def team_graph!(teams); end
  end
end

# This stores graphviz-independent views of our package graph.
# It should be optimized for fast lookup (leveraging internal indexes, which are stable due to the immutability of the package nodes)
# A `TeamGraph` should be able to consume this and basically just create a reduced version
# Lastly, each one should implement a common interface, and graphviz should use that interface and take in either types of graph via the interface
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://visualize_packs//lib/visualize_packs/graph_interface.rb#8
module VisualizePacks::GraphInterface
  interface!

  # @abstract
  #
  # source://visualize_packs//lib/visualize_packs/graph_interface.rb#14
  sig { abstract.returns(T::Set[::VisualizePacks::NodeInterface]) }
  def nodes; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://visualize_packs//lib/visualize_packs/node_interface.rb#4
module VisualizePacks::NodeInterface
  interface!

  # @abstract
  #
  # source://visualize_packs//lib/visualize_packs/node_interface.rb#22
  sig { abstract.returns(T::Array[::String]) }
  def dependencies; end

  # @abstract
  #
  # source://visualize_packs//lib/visualize_packs/node_interface.rb#26
  sig { abstract.params(node_name: ::String).returns(T::Boolean) }
  def depends_on?(node_name); end

  # @abstract
  #
  # source://visualize_packs//lib/visualize_packs/node_interface.rb#14
  sig { abstract.returns(::String) }
  def group_name; end

  # @abstract
  #
  # source://visualize_packs//lib/visualize_packs/node_interface.rb#10
  sig { abstract.returns(::String) }
  def name; end

  # @abstract
  #
  # source://visualize_packs//lib/visualize_packs/node_interface.rb#18
  sig { abstract.returns(T::Hash[::String, ::Integer]) }
  def violations_by_node_name; end
end

# source://visualize_packs//lib/visualize_packs/package_graph.rb#4
class VisualizePacks::PackageGraph
  include ::VisualizePacks::GraphInterface

  # source://visualize_packs//lib/visualize_packs/package_graph.rb#17
  sig { params(package_nodes: T::Set[::VisualizePacks::PackageNode]).void }
  def initialize(package_nodes:); end

  # source://visualize_packs//lib/visualize_packs/package_graph.rb#12
  sig { override.returns(T::Set[::VisualizePacks::NodeInterface]) }
  def nodes; end

  # source://visualize_packs//lib/visualize_packs/package_graph.rb#50
  sig { params(name: ::String).returns(T.nilable(::VisualizePacks::PackageNode)) }
  def package_by_name(name); end

  # source://visualize_packs//lib/visualize_packs/package_graph.rb#9
  sig { returns(T::Set[::VisualizePacks::PackageNode]) }
  def package_nodes; end

  class << self
    # source://visualize_packs//lib/visualize_packs/package_graph.rb#23
    sig { returns(::VisualizePacks::PackageGraph) }
    def construct; end
  end
end

# source://visualize_packs//lib/visualize_packs/package_node.rb#4
class VisualizePacks::PackageNode < ::T::Struct
  include ::VisualizePacks::NodeInterface

  const :name, ::String
  const :team_name, ::String
  const :violations_by_package, T::Hash[::String, ::Integer]
  const :dependencies, T::Set[::String]

  # source://visualize_packs//lib/visualize_packs/package_node.rb#24
  sig { override.params(node_name: ::String).returns(T::Boolean) }
  def depends_on?(node_name); end

  # source://visualize_packs//lib/visualize_packs/package_node.rb#19
  sig { override.returns(::String) }
  def group_name; end

  # source://visualize_packs//lib/visualize_packs/package_node.rb#14
  sig { override.returns(T::Hash[::String, ::Integer]) }
  def violations_by_node_name; end

  class << self
    # source://sorbet-runtime/0.5.10826/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://visualize_packs//lib/visualize_packs/package_relationships.rb#4
class VisualizePacks::PackageRelationships
  # source://visualize_packs//lib/visualize_packs/package_relationships.rb#159
  sig { params(graph: ::GraphViz, node1: ::GraphViz::Node, node2: ::GraphViz::Node, label: T.nilable(::String)).void }
  def add_dependency(graph:, node1:, node2:, label: T.unsafe(nil)); end

  # source://visualize_packs//lib/visualize_packs/package_relationships.rb#115
  sig { params(graph: ::GraphViz).void }
  def add_legend(graph); end

  # source://visualize_packs//lib/visualize_packs/package_relationships.rb#100
  sig { params(node: ::VisualizePacks::NodeInterface, graph: ::GraphViz).returns(::GraphViz::Node) }
  def add_node(node, graph); end

  # source://visualize_packs//lib/visualize_packs/package_relationships.rb#142
  sig do
    params(
      graph: ::GraphViz,
      node1: ::GraphViz::Node,
      node2: ::GraphViz::Node,
      violation_count: ::Integer,
      label: T.nilable(::String)
    ).void
  end
  def add_violation(graph:, node1:, node2:, violation_count:, label: T.unsafe(nil)); end

  # source://visualize_packs//lib/visualize_packs/package_relationships.rb#35
  sig { params(packages: T::Array[::Packs::Pack], show_all_nodes: T::Boolean).void }
  def create_graph!(packages, show_all_nodes: T.unsafe(nil)); end

  # source://visualize_packs//lib/visualize_packs/package_relationships.rb#28
  sig { params(packages: T::Array[::Packs::Pack]).void }
  def create_package_graph!(packages); end

  # source://visualize_packs//lib/visualize_packs/package_relationships.rb#10
  sig { params(teams: T::Array[::CodeTeams::Team]).void }
  def create_package_graph_for_teams!(teams); end

  # source://visualize_packs//lib/visualize_packs/package_relationships.rb#19
  sig { params(teams: T::Array[::CodeTeams::Team], show_all_teams: T::Boolean).void }
  def create_team_graph!(teams, show_all_teams: T.unsafe(nil)); end

  # source://visualize_packs//lib/visualize_packs/package_relationships.rb#42
  sig do
    params(
      graph: ::VisualizePacks::GraphInterface,
      node_names: T::Array[::String],
      show_all_nodes: T::Boolean
    ).void
  end
  def draw_graph!(graph, node_names, show_all_nodes: T.unsafe(nil)); end
end

# source://visualize_packs//lib/visualize_packs/package_relationships.rb#7
VisualizePacks::PackageRelationships::OUTPUT_FILENAME = T.let(T.unsafe(nil), String)

# A team graph reduces a PackageGraph by aggregating over packages owned by teams
#
# source://visualize_packs//lib/visualize_packs/team_graph.rb#7
class VisualizePacks::TeamGraph
  include ::VisualizePacks::GraphInterface

  # source://visualize_packs//lib/visualize_packs/team_graph.rb#17
  sig { params(team_nodes: T::Set[::VisualizePacks::TeamNode]).void }
  def initialize(team_nodes:); end

  # source://visualize_packs//lib/visualize_packs/team_graph.rb#12
  sig { override.returns(T::Set[::VisualizePacks::NodeInterface]) }
  def nodes; end

  class << self
    # source://visualize_packs//lib/visualize_packs/team_graph.rb#22
    sig { params(package_graph: ::VisualizePacks::PackageGraph).returns(::VisualizePacks::TeamGraph) }
    def from_package_graph(package_graph); end
  end
end

# source://visualize_packs//lib/visualize_packs/team_node.rb#4
class VisualizePacks::TeamNode < ::T::Struct
  include ::VisualizePacks::NodeInterface

  const :name, ::String
  const :violations_by_team, T::Hash[::String, ::Integer]
  const :dependencies, T::Set[::String]

  # source://visualize_packs//lib/visualize_packs/team_node.rb#23
  sig { override.params(node_name: ::String).returns(T::Boolean) }
  def depends_on?(node_name); end

  # source://visualize_packs//lib/visualize_packs/team_node.rb#18
  sig { override.returns(::String) }
  def group_name; end

  # source://visualize_packs//lib/visualize_packs/team_node.rb#13
  sig { override.returns(T::Hash[::String, ::Integer]) }
  def violations_by_node_name; end

  class << self
    # source://sorbet-runtime/0.5.10826/lib/types/struct.rb#13
    def inherited(s); end
  end
end
